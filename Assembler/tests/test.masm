;; This is a comment
.data:
;; msg: .string "Hello World!", 10 ;; this is a string
strlen: db 13
strlen_w: dw 60000
strlen_d: dd 1000000
strlen_q: dq 100000000

.text:
proc main
proc add

;; expect the first number in Ma register and second number in Mb register
;; return in Ma register
add:
  ;; add Ma, Mb
  hlt
  hlt
  hlt
  hlt
  hlt
  hlt

;; The mov instruction has generally two types.
;; For eg: mov8 instruction moves the byte without affecting the other bytes in the register
;; But the mov_reg8 instruction moves the byte but the upper bytes are cleared.

main:
  ;; mov doesn't have anything like movb, movw, movd
  nop
  ;; here is a list of everything that should work
  mov Ma, 1 ;; just plain mov reg, imm
  mov Ma, Mb ;; mov reg, reg
  mov Mb, strlen ;; translates to loadb Mb, strlen
  mov Mc, strlen_w ;; translates to loadw Mc, strlen_w
  mov Md, strlen_d ;; translates to loadd Mb, strlen_d
  mov Me, strlen_q ;; translates to loadq Me, strlen_q

  movq Mf, 123456789 ;; just movq reg, imm
  movq Mm1, Mm2 ;; translates to mov reg, reg
  movq Mf, strlen_q ;; translates to loadq Mf, strlen_q
  ;; movq Mf, strlen ;; error, accepts only qwords; same for strlen_d and strlen_w

  movb M1, 1 
  movb M1, M2
  movb M1, strlen 

  movw M3, 2
  movw M3, M4
  movw M3, strlen_w

  movd M5, 3
  movd M5, Ma
  movd M5, strlen_d

  movsxb Ma, 1
  movsxb Ma, M1
  movsxb Ma, strlen

  movsxw Mb, 2
  movsxw Mb, M2
  movsxw Mb, strlen_w

  movsxd Mc, 3
  movsxd Mc, M3
  movsxd Mc, strlen_w

  moveb M1, 1
  moveb M1, M2
  moveb M1, strlen

  movew M3, 2
  movew M3, M4
  movew M3, strlen_w

  moved M5, 3
  moved M5, Ma
  moved M5, strlen_d

  hlt ;; we use halt here because this is what ultimately stops the program so there is no point in having a ret here

;; main:

.data:
test: db 123

;; Here is how thing go
;; The assembler looks for the main procedure by default
;; The first instruction in the main procedure is the very first instruction that will be executed
;; What if there are more procedures before the main procedure?
;; In this case, the procedures will be moved to the very end
;; They will still be callable
;; The same for labels as well

;; In the given example, even though add is before main, in the final binary, it will be at
;; the very last. Merry doesn't support anything like providing entry point.
;; Though it could be added, it introduces problems and new ways for people to exploit 
;; the programs and so the very first instruction at address 0 is the very first instruction executed.
;; If no branches are present then the execution is straightforward