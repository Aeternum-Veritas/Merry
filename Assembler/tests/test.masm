;; This is a comment
.data:
;; msg: .string "Hello World!", 10 ;; this is a string
strlen: db 13
strlen_w: dw 60000
strlen_d: dd 1000000
strlen_q: dq 100000000

.text:
proc main
proc add

;; expect the first number in Ma register and second number in Mb register
;; return in Ma register
add:
  ;; add Ma, Mb
  hlt
  hlt
  hlt
  hlt
  hlt
  hlt

;; The mov instruction has generally two types.
;; For eg: mov8 instruction moves the byte without affecting the other bytes in the register
;; But the mov_reg8 instruction moves the byte but the upper bytes are cleared.

main:
  nop
  mov Ma, 1 ;; just plain mov reg, imm
  mov Ma, Mb ;; mov reg, reg
  mov Mb, strlen ;; translates to loadb Mb, strlen
  mov Mc, strlen_w ;; translates to loadw Mc, strlen_w
  mov Md, strlen_d ;; translates to loadd Mb, strlen_d
  mov Me, strlen_q ;; translates to loadq Me, strlen_q

  movq Mf, 123456789 ;; just movq reg, imm
  movq Mm1, Mm2 ;; translates to mov reg, reg
  movq Mf, strlen_q ;; translates to loadq Mf, strlen_q
  ;; movq Mf, strlen ;; error, accepts only qwords; same for strlen_d and strlen_w

  movb M1, 1 
  movb M1, M2
  movb M1, strlen 

  movw M3, 2
  movw M3, M4
  movw M3, strlen_w

  movd M5, 3
  movd M5, Ma
  movd M5, strlen_d

  ;; the following three moves are restricted to register operands only
  ;; The above move instructions affect the upper bytes of the destination register
  ;; zeroing it out but the below will not do that
  ;; There is no moveq and using variables and immediates is not allowed
  moveb Ma, Mb
  movew M1, M2
  moved Mm1 Mm2

  ;; NOTE: The assembler doesn't strictly require the use of commas
  ;; in fact, the assembler ignores all the commas
  ;; They are just their to increase readability
  ;; So the following line is completely valid as well

  ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, ;; ignored by assembler

 ;; movsxb Ma, 1
 ;; movsxb Ma, M1
 ;; movsxb Ma, strlen
;;
 ;; movsxw Mb, 2
 ;; movsxw Mb, M2
 ;; movsxw Mb, strlen_w
;;
 ;; movsxd Mc, 3
 ;; movsxd Mc, M3
 ;; movsxd Mc, strlen_w
;;
 ;; moveb M1, 1
 ;; moveb M1, M2
 ;; moveb M1, strlen
;;
 ;; movew M3, 2
 ;; movew M3, M4
 ;; movew M3, strlen_w
;;
 ;; moved M5, 3
 ;; moved M5, Ma
 ;; moved M5, strlen_d

  hlt ;; we use halt here because this is what ultimately stops the program so there is no point in having a ret here

;; main:

.data:
test: db 123

;; Here is how thing go
;; The assembler looks for the main procedure by default
;; The first instruction in the main procedure is the very first instruction that will be executed
;; What if there are more procedures before the main procedure?
;; In this case, the procedures will be moved to the very end
;; They will still be callable
;; The same for labels as well

;; In the given example, even though add is before main, in the final binary, it will be at
;; the very last. Merry doesn't support anything like providing entry point.
;; Though it could be added, it introduces problems and new ways for people to exploit 
;; the programs and so the very first instruction at address 0 is the very first instruction executed.
;; If no branches are present then the execution is straightforward