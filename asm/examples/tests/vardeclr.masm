;; This is a comment

;; Variable declaration has types: byte, word, dword, qword, array, string.

db a 123
dw b 64647
dd c 8384
dq d 73884

;; Doing the following will not define a variable but it will be included in the final binary.
dq 123456789 ;; cannot be accessed anymore
;; The way these variables are placed in memory is in the same order they are defined in.

dw 0x777F

;; Doing "dw a 0c8812 0b11010110" is not valid because this is not an array

res dq e 10 ;; This reserves 10 qwords and 'e' can be used to access these

str f "Wow!" ;; A string

db g 65

str h "Hello".g.", This is me.".10.0 ;; Concatenating strings. Notice the 'g' as well.

;; you cannot use 'str' with 'res' obviously.

;; You can also do the following obviously
dq i ((123 + a + (b * c)/d - 0xFFFF) >> 2) & 0xFFFFFFFF

db is_defined (g == 65) && ((i >> 1) != 0)

;; All of these expressions are evaluated after parsing is done followed by the creation of the symbol table

;; The assembler works in the following way:
;; Lexing and Parsing is done in pretty much the same step.
;; We do the same with all the compilation units that were included.
;; After that we go through the nodes of each compilation unit.
;; Going through each unit in the order they were included, we remove the nodes based on the macros, replace some nodes, and then build a symbol table.
;; While we do the above step, we perform evaluation on the expressions.
;; We follow-up with semantic analysis i.e checking if procedures are properly defined.
;; Finally we do code generation and spit out the binary.

;; GOSH! So many steps.

;; including other files
;; If any variables are declared in abc.masm, they will follow the above in memory in the same way.
use abc.masm

!def ABC_INCLUDED ;; defining a macro

!def use_me 123 + 2333