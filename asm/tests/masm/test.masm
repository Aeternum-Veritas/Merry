;; This contains just the code
;; Any data here will result in an error

;; There are two types of labels: procedures and simple labels

proc main ;; The above is a procedure i.e it is globally visible meaning it may be called from any file

main ;; the definition of proc main

;; Given that parsing becomes simpler, labels cannot share the same name throughout the same project
_just_a_label
  nop
  halt

;; variants of add
  add Mm1, 1234 ;; regr + imm
  add Ma, Mb    ;; regr + regr
  add M1, a     ;; regr + variable
  ;; unfortunately there is no "add M1, [Ma]" with address in Ma
  ;; The reason for this is that there is no instruction in the VM that supports this
  ;; The ISA of VM was to make execution faster so the complicated decoding can be avoided
  ;; This has limited us in the number of instructions we can have.
  ;; We may implement extended ISA in the future

  ;; The same from above can be copied for sub, mul, div and mod
  sub Mm1, 1234 ;; regr - imm
  sub Ma, Mb    ;; regr - regr
  sub M1, a     ;; regr - variable

  mul Mm1, 1234 ;; regr * imm
  mul Ma, Mb    ;; regr * regr
  mul M1, a     ;; regr * variable

  div Mm1, 1234 ;; regr / imm
  div Ma, Mb    ;; regr / regr
  div M1, a     ;; regr / variable

  mod Mm1, 1234 ;; regr % imm
  mod Ma, Mb    ;; regr % regr
  mod M1, a     ;; regr % variable
  
  ;; There isn't much difference between the signed and unsigned version of the arithmetic
  ;; instructions. If you provide immediates that are properly sign extended then that will work
  ;; too. Signed and unsigned both affect the same set of flags and so using any is fine.
  ;; The below iadd with immediate performs sign extension to the immediate which the unsigned
  ;; doesn't do. Unless dedicated versions of the signed instructions for all lengths of data
  ;; types is provided, the program has no choice but to perform the sign extension first and
  ;; then proceeding to use the unsigned instructions. For eg: iadd M1, Mm1 assumes a 64-bit
  ;; signed value in both registers. So you will have to perform a sign extension first.
  ;; for example: say you have to add 7288 and -73 but you have stored -73 as byte in memory
  ;; you may do
  movsxb Ma, Ma ;; assuming the operand is already in Ma
  iadd Ma, 7288 ;; Now it behaves as intended

  iadd Mm5, -347 ;; treat as signed
  iadd M1, Mm1
  
  isub Mm5, -347
  isub M1, Mm1
  
  imul Mm5, -347
  imul M1, Mm1
  
  idiv Mm5, -347
  idiv M1, Mm1
  
  imod Mm5, -347
  imod M1, Mm1

  ;; NOTE: The assembler ignores all commas so you can do whatever you want.
  
  ;; FLoating point instructions don't take anything other than registers as operands
  ;; Having immediates would be convinient, isn't it?
  ;; I am getting new ideas as I develop the assembler so in future
  addf M1, M2 ;; 32-bit floating point values
  addlf M1, M2 ;; 64-bit floating point values

  subf M1, M2 
  sublf M1, M2

  mulf M1, M2 
  mullf M1, M2

  divf M1, M2 
  divlf M1, M2

  ;; No mods for floats

  mov Mf, 56379 ;; 32-bit immediates only
  mov Me, 7238.544 ;; only 32-bit floating point numbers
  mov Ma, Mb
  mov Mc, d ;; translated to corresponding load instruction
  mov Ma, _just_a_label ;; This also works now. The address of the label is stored.
                        ;; since we allow variables and labels to have the same name
                        ;; variables will get the priority

  movl Mf, 85789375389 ;; 64-bit immediates
  movl Mm4, 378246.437437 ;; 64-bit floating point immediate
  ;; movl M5, M3 ;; This won't throw an error but this is useless to do as the same can be done with mov M5, M3
  ;; movl Ma, a  ;; The same as mov regr, any_var 

  ;; These below only work on registers
  movb Ma, Mb ;; move the lowest byte from Mb to Ma, overwrites the above bytes of Ma
  movw Ma, Mb ;; move the lower 2 bytes from Mb to Ma, overwrites the above bytes of Ma
  movd Ma, Mb ;; move the lower 4 bytes from Mb to Ma, overwrites the above bytes of Ma

  ;; It would have made more sense if "movl regr, var" forced the assembler to translate it to 
  ;; 64-bit load no matter what but then that would be preety useless.

  ;; These instructions will ignore the numbers after the '.'
  movsxb Ma, 65   ;; for bytes only
  movsxw Ma, 7236 ;; for word only
  movsxd Ma, -1739 ;; for dwords only 

  movsxb Ma, Mb ;; sign extends only the specified number of bytes(overwrites the higher bytes)
  movsxw Ma, Mb ;; sign extends only the specified number of bytes(overwrites the higher bytes)
  movsxd Ma, Mb ;; sign extends only the specified number of bytes(overwrites the higher bytes) 
  
  movsxb Ma, a ;; translated to corresponding load and movesxX instruction
  movsxw Ma, a ;; translated to corresponding load and movesxX instruction
  movsxd Ma, a ;; translated to corresponding load and movesxX instruction
  
  ;; Jump instruction has two formats in truth.
  ;; One takes the literal address to jump to while the other takes an offset
  ;; Taking an offset isn't really useful for now
  ;; So we will only have one type of JMP.
  jmp _just_a_label ;; only takes labels as the operand.

  call main ;; There is no rule that says that call should work on procedures only
            ;; but do make sure that there is a ret somewhere after the label
  call Ma   ;; Newly added instruction- Will be helpful for function pointers
  ret

  ;; SVA= Stack Variable Access, SVC = Stack Variable Change
  ;; negative offset and attempts to change BP's old value will result in error
  sva Ma, 829 ;; Access the variable at offset of 829 from BP and put it in Ma
  sva Ma, a   ;; The offset is in 'a'
  sva Ma, Mb  ;; The offset is in Mb
  svc Ma, 3   ;; Change the variable at offset 3 from BP to the value in Ma
  svc Ma, a   ;; The offset is in 'a'
  svc Ma, Mb   ;; The offset is in Mb

;; Here is the thing.
;; A procedure or a label can have the same name as an identifier
;; The assembler will know which you are referencing based on the context.