;; This contains just the code
;; Any data here will result in an error

;; There are two types of labels: procedures and simple labels

proc main ;; The above is a procedure i.e it is globally visible meaning it may be called from any file

main ;; the definition of proc main

;; Given that parsing becomes simpler, labels cannot share the same name throughout the same project
_just_a_label
  nop
  halt

;; variants of add
  add Mm1, 1234 ;; regr + imm
  add Ma, Mb    ;; regr + regr
  add M1, a     ;; regr + variable
  ;; unfortunately there is no "add M1, [Ma]" with address in Ma
  ;; The reason for this is that there is no instruction in the VM that supports this
  ;; The ISA of VM was to make execution faster so the complicated decoding can be avoided
  ;; This has limited us in the number of instructions we can have.
  ;; We may implement extended ISA in the future

  ;; The same from above can be copied for sub, mul, div and mod
  sub Mm1, 1234 ;; regr - imm
  sub Ma, Mb    ;; regr - regr
  sub M1, a     ;; regr - variable

  mul Mm1, 1234 ;; regr * imm
  mul Ma, Mb    ;; regr * regr
  mul M1, a     ;; regr * variable

  div Mm1, 1234 ;; regr / imm
  div Ma, Mb    ;; regr / regr
  div M1, a     ;; regr / variable

  mod Mm1, 1234 ;; regr % imm
  mod Ma, Mb    ;; regr % regr
  mod M1, a     ;; regr % variable
  
  ;; There isn't much difference between the signed and unsigned version of the arithmetic
  ;; instructions. If you provide immediates that are properly sign extended then that will work
  ;; too. Signed and unsigned both affect the same set of flags and so using any is fine.
  ;; The below iadd with immediate performs sign extension to the immediate which the unsigned
  ;; doesn't do. Unless dedicated versions of the signed instructions for all lengths of data
  ;; types is provided, the program has no choice but to perform the sign extension first and
  ;; then proceeding to use the unsigned instructions. For eg: iadd M1, Mm1 assumes a 64-bit
  ;; signed value in both registers. So you will have to perform a sign extension first.

  iadd Mm5, -347 ;; treat as signed
  iadd M1, Mm1
  
  isub Mm5, -347
  isub M1, Mm1
  
  imul Mm5, -347
  imul M1, Mm1
  
  idiv Mm5, -347
  idiv M1, Mm1
  
  imod Mm5, -347
  imod M1, Mm1

  ;; NOTE: The assembler ignores all commas so you can do whatever you want.
  
  ;; FLoating point instructions don't take anything other than registers as operands
  ;; Having immediates would be convinient, isn't it?
  ;; I am getting new ideas as I develop the assembler so in future
  addf M1, M2 ;; 32-bit floating point values
  addlf M1, M2 ;; 64-bit floating point values

  subf M1, M2 
  sublf M1, M2

  mulf M1, M2 
  mullf M1, M2

  divf M1, M2 
  divlf M1, M2

  ;; No mods for floats

;; Here is the thing.
;; A procedure or a label can have the same name as an identifier
;; The assembler will know which you are referencing based on the context.