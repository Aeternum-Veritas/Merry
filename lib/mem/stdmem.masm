proc __builtin_std_mem_init
proc __builtin_std_alloc
proc __builtin_std_mem_check_free_blocks
proc __builtin_std_mem_request_more_mem
proc __builtin_std_free

;; This is a quick error logging procedure with nothing fancy
proc __builtin_std_mem_log_err

;; Utility procedures
proc __builtin_std_mem_append_to_free        ;; used by __builtin_std_free
proc __builtin_std_mem_append_to_allocated   ;; used by __builtin_std_alloc
proc __builtin_std_mem_remove_from_free      ;; used by __builtin_std_alloc
proc __builtin_std_mem_remove_from_allocated ;; used by __builtin_std_free

proc __builtin_std_mem_populate_free_head       ;; used to fill the free head
proc __builtin_std_mem_populate_allocated_head  ;; used to fill allocated head

;; ARGS: Ma = address to make the head
;; RETURNS: Nothing
__builtin_std_mem_populate_free_head
    
    ;; call to this procedure means that the free head is empty
    ;; and so is the tail
    ;; PREV and NXT must be NULL
    storeq Ma, _Mstd_free_mem_head
    storeq Ma, _Mstd_free_mem_tail

    ret

;; ARGS: Ma = address to make the head
;; RETURNS: Nothing
__builtin_std_mem_populate_allocated_head
    
    ;; call to this procedure means that the allocated head is empty
    ;; and so is the tail
    ;; PREV and NXT must be NULL
    storeq Ma, _Mstd_allocated_mem_head
    storeq Ma, _Mstd_allocated_mem_tail

    ret

;; ARGS: Ma = address for the block
;; RETURNS: Nothing
__builtin_std_mem_append_to_free

    ;; The block that was provided must have NULL for NXT and PREV
    call __builtin_quick_save
    
    loadq M1, _Mstd_free_mem_head
    loadq M2, _Mstd_free_mem_tail

    cmp M1, _MSTD_NULL_
    je _std_mem_append_to_free_populate_head

    ;; The job requires just the tail
    push M2
    sub M2, _MSTD_MEM_METADATA_NXT_
    storeq Ma, M2
    pop M2

    sub Ma, _MSTD_MEM_METADATA_PREV_
    storeq M2, Ma

    jmp _std_mem_append_to_free_done 

 _std_mem_append_to_free_populate_head
    call __builtin_std_mem_populate_free_head

 _std_mem_append_to_free_done
    call __builtin_quick_restore
    ret

;; ARGS: Ma = address for the block
;; RETURNS: Nothing
__builtin_std_mem_append_to_allocated

    ;; The block that was provided must have NULL for NXT and PREV
    call __builtin_quick_save
    
    loadq M1, _Mstd_allocated_mem_head
    loadq M2, _Mstd_allocated_mem_tail

    cmp M1, _MSTD_NULL_
    je _std_mem_append_to_allocated_populate_head

    ;; The job requires just the tail
    push M2
    sub M2, _MSTD_MEM_METADATA_NXT_
    storeq Ma, M2
    pop M2

    sub Ma, _MSTD_MEM_METADATA_PREV_
    storeq M2, Ma

    jmp _std_mem_append_to_free_done 

 _std_mem_append_to_allocated_populate_head
    call __builtin_std_mem_populate_allocated_head

 _std_mem_append_to_allocated_done
    call __builtin_quick_restore
    ret

;; ARGS: Ma = address for the block to remove
;; RETURNS: Nothing
__builtin_std_mem_remove_from_free
    call __builtin_quick_save

    ;; Updates the Free List and makes NXT and PREV NULL
    movl Mb, Ma             ;; temporary storage
    
    movl Mm1, _MSTD_NULL_

    sub Mb, _MSTD_MEM_METADATA_PREV_
    loadq M1, Mb
    storeq Mm1, Mb
    sub Mb, _MSTD_MEM_METADATA_PREV_
    loadq M2, Mb
    storeq Mm1, Mb

    ;; M1 and M2 now contain the neighbors of the block 
    
    ;; make some internal value changes
    cmp Ma, _Mstd_free_mem_head
    je _std_mem_remove_from_free_is_head

    cmp Ma, _Mstd_free_mem_tail
    je _std_mem_remove_from_free_is_tail

    jmp _std_mem_remove_from_free_continue 

 _std_mem_remove_from_free_is_head
    storeq M2, _Mstd_free_mem_head     ;; update the head

 _std_mem_remove_from_free_is_tail
    storeq M1, _Mstd_free_mem_tail     ;; update the tail
    
 _std_mem_remove_from_free_continue
    cmp M1, _MSTD_NULL_
    je _std_mem_remove_from_free_continue1

    push M1
    sub M1, _MSTD_MEM_METADATA_NXT_
    storeq M2, M1
    pop M1

 _std_mem_remove_from_free_continue1
    cmp M2, _MSTD_NULL_
    je _std_mem_remove_from_free_done

    sub M2, _MSTD_MEM_METADATA_PREV_
    storeq M1, M2

 _std_mem_remove_from_free_done
    call __builtin_quick_restore
    ret

;; ARGS: Ma = address for the block to remove
;; RETURNS: Nothing
__builtin_std_mem_remove_from_allocated
    call __builtin_quick_save

    ;; Updates the Allocated List and makes NXT and PREV NULL
    movl Mb, Ma             ;; temporary storage
    
    movl Mm1, _MSTD_NULL_

    sub Mb, _MSTD_MEM_METADATA_PREV_
    loadq M1, Mb
    storeq Mm1, Mb
    sub Mb, _MSTD_MEM_METADATA_PREV_
    loadq M2, Mb
    storeq Mm1, Mb

    ;; M1 and M2 now contain the neighbors of the block 
    
    ;; make some internal value changes
    cmp Ma, _Mstd_allocated_mem_head
    je _std_mem_remove_from_allocated_is_head

    cmp Ma, _Mstd_allocated_mem_tail
    je _std_mem_remove_from_allocated_is_tail

    jmp _std_mem_remove_from_allocated_continue 

 _std_mem_remove_from_allocated_is_head
    storeq M2, _Mstd_allocated_mem_head     ;; update the head

 _std_mem_remove_from_allocated_is_tail
    storeq M1, _Mstd_free_mem_tail     ;; update the tail
    
 _std_mem_remove_from_allocated_continue
    cmp M1, _MSTD_NULL_
    je _std_mem_remove_from_allocated_continue1

    push M1
    sub M1, _MSTD_MEM_METADATA_NXT_
    storeq M2, M1
    pop M1

 _std_mem_remove_from_allocated_continue1
    cmp M2, _MSTD_NULL_
    je _std_mem_remove_from_allocated_done

    sub M2, _MSTD_MEM_METADATA_PREV_
    storeq M1, M2

 _std_mem_remove_from_allocated_done
    call __builtin_quick_restore
    ret


;; Initialize memory system.
;; ARGS: None, RETURN: Nothing
__builtin_std_mem_init
    call __builtin_quick_save
    
    ;; Initialize internal memory management values
    loadq Ma, _Mstd_free_mem_start_addr
    storeq Ma, _Mstd_allocable_mem_start
    storeq Ma, _Mstd_allocable_mem_end

    ;; Set initial pointers to NULL
    movl Ma, _MSTD_NULL_
    storeq Ma, _Mstd_allocated_mem_head
    storeq Ma, _Mstd_allocated_mem_tail
    storeq Ma, _Mstd_free_mem_head
    storeq Ma, _Mstd_free_mem_tail

    ;; Initialize allocated memory count
    movl Ma, 0
    storeq Ma, _Mstd_allocated_mem

    ;; Calculate total memory size
    loadq Ma, _Mstd_num_of_pages
    mul Ma, _MSTD_MEM_PAGE_LEN
    sub Ma, _Mstd_allocable_mem_start
    storeq Ma, _Mstd_allocable_mem_len      ;; Store available memory size

    call __builtin_quick_restore
    ret

;; ARGS: Ma = PTR to message, Mb= length of msg
__builtin_std_mem_log_err
    mov Mc, Mb
    sout Ma
    mov Ma, 10
    cout Ma
    mov Ma, 1             ;; Unsuccessful return
    intr _M_EXIT_         ;; The entire VM stops(unless child processes are running)

;; ARGS: Nothing
;; RETURNS: 0 for success and 1 for failure
__builtin_std_mem_request_more_mem